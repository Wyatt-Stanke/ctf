# Pipeline CTF — Intended Solving Path

## Step 1: Reconnaissance

1. **Visit the status page** (`/`).  Read the HTML source — there are
   comments referencing `/_logs/`, `/_ghes/dispatch.html`, and the
   internal repository `github.nimbusops.internal/NimbusOps/status-dash`.

2. **Check `/robots.txt`** — it reveals three hidden paths:
   - `/_logs/`
   - `/.github/`
   - `/.env.example`

3. **Browse `/_logs/latest.json`** — shows recent build run IDs,
   naming conventions, actors, commit SHAs, and statuses.  Note
   that run #116 has `"status": "failure"` — this is a breadcrumb.

4. **Read `/_logs/deploy-116.log`** — a failed deploy log from the DNS
   outage.  The debug dump step ran but the auth file wasn't written yet
   (shows `(file not found)`).  This teaches the player that the debug
   dump *does* run on failure, but the auth file needs to exist.

5. **Read `/.env.example`** — shows placeholder variable names including
   `DEPLOY_KEY=change-me-before-deploying`.

6. **Explore the GHES interface** (`/_ghes/`).  The dashboard links to
   repo, actions, issues, PRs, wiki, and commits.  Notable finds:
   - **Issue #55** (`issue-55.html`) — akovacs asks "are our secrets
     safe in Actions logs?" and msantiago + jpark dismiss the concern.
     This is a narrative hint that the team is overconfident about
     masking.
   - **Wiki > Secret Management** (`wiki-secrets.html`) — documents
     exactly how `DEPLOY_KEY` is base64-encoded during deploys and
     quotes the security audit saying "no instances of secret exposure".
   - **Wiki > On-Call Runbook** (`wiki-runbook.html`) — mentions
     `skip_preflight` and `registry_override` as available options.
   - **Commit history** (`commits.html`) — shows the Jan 28 failed
     deploy matching the deploy-116 log.

## Step 2: Understand the CI/CD Workflow

Navigate to `/.github/workflows/deploy-prod.yml` and read it carefully.

Key observations:

- **Trigger:** `push` to `main` **or** `workflow_dispatch`.
- **Dispatch inputs:**
  - `environment` (dropdown: staging / production)
  - `registry_override` — **not shown in the dispatch form by default**
  - `skip_preflight` — **also hidden**
- **Step 4 (Authenticate to registry):**
  Writes `base64(flag)` to `/tmp/.registry-auth` *before* the `curl`
  that contacts the registry.  This means the auth file is created even
  if the `curl` fails.
- **Step 7 (Dump debug info):**
  Runs with `if: failure()`.  It **dumps the contents of
  `/tmp/.registry-auth`** (the base64-encoded flag) to the log.
- **Masking:** GitHub Actions only masks the **literal** secret string.
  The base64-encoded version is a different string and is **NOT masked**.

## Step 3: Trigger the Exploit

Go to `/_ghes/dispatch.html` (the workflow dispatch page).

The form needs to be submitted with specific query parameters.  The
simplest way is to craft the URL directly:

```
/_ghes/dispatch.html?environment=production&registry_override=evil.nimbusops.internal&skip_preflight=true
```

Why these values?

| Parameter | Value | Reason |
|-----------|-------|--------|
| `environment` | `production` | Required input. |
| `registry_override` | `evil.nimbusops.internal` | Must contain "nimbusops" to pass the Step 1 validation check, but must **not** be a real host so the `curl` in Step 5 fails. |
| `skip_preflight` | `true` | Skips the early connectivity check (Step 2) that would reject before the auth file is written. |

With preflight skipped the pipeline reaches Step 4, writes the auth
file, then fails at the `curl` in Step 5.  Because the job is now in a
`failure()` state, Step 7 fires and dumps the base64 auth file.

## Step 4: Decode the Flag

The build output includes a base64 string:

```
ZmxhZ3tsMGdfbTRzazFuZ18xc19uMHRfczNjdXIxdHl9
```

This is **not** masked because the masking engine only knows the
literal secret value, not its base64 form.

```bash
echo "ZmxhZ3tsMGdfbTRzazFuZ18xc19uMHRfczNjdXIxdHl9" | base64 -d
# => flag{l0g_m4sk1ng_1s_n0t_s3cur1ty}
```

## Common Pitfalls

- **Not skipping preflight:** Without `skip_preflight=true` the pipeline
  fails at Step 2 (before the auth file is written), so there's nothing
  to dump.
- **Bad registry_override:** The value must contain "nimbusops" or the
  validation in Step 1 rejects it.  But it also needs to be unreachable
  so the later `curl` fails and triggers the debug dump.
- **Looking only at masked output:**  Players might see `***` in the
  normal secret positions and assume nothing leaked — they need to
  scroll to the *failure debug* section.
